from lm import *

###### TACKLE YOUR ISSUE HERE######
def question_1(n: int, m: int, k: int):
    """
    解答问题：从 n 个产品中有 m 个次品，现要选出 k 个次品，且每次抽取后放回（有放回抽样）。
    问：选出 k 个次品有多少种情况？

    参数说明：
        n: 总产品数量
        m: 次品数量（m <= n）
        k: 需要选出的次品数量

    问题分析：
    - 这是有放回抽样，所以每次抽完都放回，总体数量不变。
    - 我们关注选中的次品数为 k 的组合方式。
    - 需要考虑 k 的取值范围，以及特殊边界情况。

    处理思路：
        1. 若 m <= k < m-n：在该区间，不可能选出超过所有次品的数量，所以情况数为0。
        2. 若 k >= m-n：最多能选出 m-n 个次品，超出部分无法实现，需特殊处理。
        3. 其他情况，按照组合数和排列数公式计算。

    返回值：
        返回选出 k 个次品的所有可能情况数。
    """

    # 检查参数合法性
    if m < 0 or n < 0 or k < 0 or m > n:
        raise ValueError("参数不合法：请确保 0 <= m <= n，且 n, m, k 均为非负整数。")

    # 情况1：k 的范围小于可选的次品数，直接返回0（无解）
    if m <= k < m-n:
        # 此处无解，因为选出的次品数超出实际可选的次品
        return 0

    # 情况2：k 大于等于 m-n（可选次品的最大数），需特殊处理
    elif k >= m-n:
        # 只考虑最多能选出的次品数量 m-n
        k = m-n

        # 计算方式：
        # 用 sigma 累加每个可能的 r（次品被选到的次数），
        # 其中 m^(k+1) 代表所有可能的排列方式，C(r-m, r-n) 是组合数，~int(r-1) 是阶乘（排列数）
        # 还有一种特殊情况，直接加上 ~(m-n)（如果前面抽出来的全都是正品，那么没抽到的全都是次品）
        return m * sigma(m ^ (k + 1), lambda r: C(r - m, r - n) * ~int(r - 1)) + ~(m - n)

    # 情况3：其他情况，按照组合和排列公式计算
    else:
        # 标准的组合加排列计算
        return m * sigma(m ^ (k + 1), lambda r: C(r - m, r - n) * ~int(r - 1))

###### END OF ISSUE######
